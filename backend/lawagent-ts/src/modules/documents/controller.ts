import { Request, Response } from 'express';
import { prisma } from '@/services/prisma';
import { sendSuccess, sendServerError, sendNotFound } from '@/utils/helpers';
import { asyncHandler } from '@/middleware/errorHandler';
import { generateSignedDownloadUrl } from '@/services/storage'; // Assuming a storage service for signed URLs

/**
 * Get a paginated and filterable list of documents for the authenticated user.
 */
export const getDocuments = asyncHandler(async (req: Request, res: Response) => {
  try {
    if (!req.user?.userId) {
      return sendServerError(res, 'User not authenticated');
    }

    const userId = req.user.userId;
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 10;
    const caseId = req.query.caseId as string;
    const needsReview = req.query.needsReview !== undefined ? String(req.query.needsReview).toLowerCase() === 'true' : undefined;
    const docType = req.query.docType as string; // Corresponds to DocumentType enum

    const skip = (page - 1) * limit;

    let whereClause: any = {
      uploaderId: userId, // Use uploaderId from schema
    };

    if (caseId) {
      whereClause.caseId = caseId;
    }
    if (needsReview !== undefined) {
      whereClause.reviewStatus = needsReview ? 'PENDING' : undefined; // Map needsReview to reviewStatus
    }
    if (docType) {
      whereClause.docType = docType; // Use docType from schema
    }

    const [documents, total] = await Promise.all([
      prisma.document.findMany({
        where: whereClause,
        skip,
        take: limit,
        orderBy: { uploadedAt: 'desc' },
        include: {
          uploader: { select: { id: true, name: true } }, // Include uploader details for 'uploadedBy'
          case: { select: { id: true, title: true } }, // Include case details
        },
      }),
      prisma.document.count({ where: whereClause }),
    ]);

    // Format documents to match the desired response structure
    const formattedDocuments = documents.map(doc => ({
      id: doc.id,
      fileName: doc.originalName, // Use originalName from schema
      caseId: doc.caseId,
      uploadedBy: doc.uploader?.name || 'Unknown', // Use uploader name
      uploadedAt: doc.uploadedAt.toISOString(), // Ensure ISO format
      reviewStatus: doc.reviewStatus, // Use reviewStatus from schema
      docType: doc.docType, // Use docType from schema
      // signedUrl: 'placeholder_signed_url', // This will be generated by a separate endpoint
      // storageKey: doc.storagePath, // Or storagePath if that's the key
    }));

    return sendSuccess(res, 'Documents retrieved successfully', {
      documents: formattedDocuments,
      total,
      page,
      limit,
    });
  } catch (error) {
    console.error('Get documents error:', error);
    return sendServerError(res, 'Failed to retrieve documents');
  }
});

/**
 * Generate a time-limited signed URL for a document.
 */
export const getSignedUrl = asyncHandler(async (req: Request, res: Response) => {
  try {
    if (!req.user?.userId) {
      return sendServerError(res, 'User not authenticated');
    }

    const { id } = req.params;
    const userId = req.user.userId;

    const document = await prisma.document.findUnique({
      where: { id },
    });

    if (!document || document.uploaderId !== userId) { // Use uploaderId from schema
      return sendNotFound(res, 'Document not found or unauthorized access');
    }

    // Assuming generateSignedUrl function exists in '@/services/storage'
    // It should take storagePath and return a time-limited URL
    const signedUrl = await generateSignedDownloadUrl(document.storagePath);

    return sendSuccess(res, 'Signed URL generated successfully', { signedUrl });
  } catch (error) {
    console.error('Get signed URL error:', error);
    return sendServerError(res, 'Failed to generate signed URL');
  }
});
